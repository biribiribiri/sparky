package dogtra2300ncp

import (
	"log"
	"math"
	"math/cmplx"
	"strings"
	"time"
)

const Freq = 27150000 // 27.15 MHz

// Command format
// [Prefix] [Cmd][CollarID][Intensity] [Cmd][CollarID][Intensity] ...
//
// When "nick" button is pressed on the remote, the [Cmd][CollarID][Intensity]
// sequence is repeated 3 times. For the continuous and vibrate commands, the
// [Cmd][CollarID][Intensity] sequence repeats until the button is released.

const prefix = "1111111000000011111110000000"

type Cmd string

const NickCmd Cmd = "111100001001001101101001001101101001"
const ContinuousCmd Cmd = "111100001001001101101101101001001001"
const VibrateCmd Cmd = "111100001001001101101101001001101001"
const PairingCmd Cmd = "111100001101101101101001001001001001"

type CollarID string

const CollarID1 CollarID = "101001001001001101001001101001101001"
const CollarID2 CollarID = "101001001001001101001001101001101101"

var intensities map[int]string = map[int]string{
	0:   "010100000000000000000000000000",
	1:   "011010000000000000000000000000",
	2:   "011101000000000000000000000000",
	3:   "011110100000000000000000000000",
	4:   "011111010000000000000000000000",
	5:   "011111101000000000000000000000",
	6:   "011111110100000000000000000000",
	7:   "011111111010000000000000000000",
	8:   "011111111101000000000000000000",
	9:   "011111111110100000000000000000",
	10:  "001010000000000000000000000000",
	11:  "001101000000000000000000000000",
	12:  "001111010000000000000000000000",
	13:  "001111110100000000000000000000",
	14:  "001111111010000000000000000000",
	15:  "001111111101000000000000000000",
	16:  "001111111110100000000000000000",
	17:  "001111111111010000000000000000",
	18:  "000101000000000000000000000000",
	19:  "000110100000000000000000000000",
	20:  "000111010000000000000000000000",
	21:  "000111101000000000000000000000",
	22:  "000111110100000000000000000000",
	23:  "000111111010000000000000000000",
	24:  "000111111101000000000000000000",
	25:  "000111111110100000000000000000",
	26:  "000111111111101000000000000000",
	27:  "000011010000000000000000000000",
	28:  "000011110100000000000000000000",
	29:  "000011111101000000000000000000",
	30:  "000011111111010000000000000000",
	31:  "000011111111110100000000000000",
	32:  "000001101000000000000000000000",
	33:  "000001111010000000000000000000",
	34:  "000001111110100000000000000000",
	35:  "000001111111101000000000000000",
	36:  "000001111111111010000000000000",
	37:  "000000110100000000000000000000",
	38:  "000000111101000000000000000000",
	39:  "000000111111010000000000000000",
	40:  "000000111111101000000000000000",
	41:  "000000111111110100000000000000",
	42:  "000000111111111010000000000000",
	43:  "000000010100000000000000000000",
	44:  "000000011101000000000000000000",
	45:  "000000011111010000000000000000",
	46:  "000000011111110100000000000000",
	47:  "000000011111111101000000000000",
	48:  "000000001010000000000000000000",
	49:  "000000001110100000000000000000",
	50:  "000000001111101000000000000000",
	51:  "000000001111111010000000000000",
	52:  "000000001111111101000000000000",
	53:  "000000001111111110100000000000",
	54:  "000000001111111111010000000000",
	55:  "000000000101000000000000000000",
	56:  "000000000111010000000000000000",
	57:  "000000000111110100000000000000",
	58:  "000000000111111101000000000000",
	59:  "000000000111111111010000000000",
	60:  "000000000010100000000000000000",
	61:  "000000000011101000000000000000",
	62:  "000000000011111010000000000000",
	63:  "000000000011111110100000000000",
	64:  "000000000011111111010000000000",
	65:  "000000000011111111101000000000",
	66:  "0000000000111111111101000000000",
	67:  "101010000000000000000000000000",
	68:  "101110100000000000000000000000",
	69:  "101111101000000000000000000000",
	70:  "101111111010000000000000000000",
	71:  "101111111110100000000000000000",
	72:  "100101000000000000000000000000",
	73:  "100111010000000000000000000000",
	74:  "100111110100000000000000000000",
	75:  "100111111101000000000000000000",
	76:  "100111111111010000000000000000",
	77:  "100010100000000000000000000000",
	78:  "100011101000000000000000000000",
	79:  "100011111010000000000000000000",
	80:  "100011111110100000000000000000",
	81:  "100011111111110100000000000000",
	82:  "100001110100000000000000000000",
	83:  "100001111110100000000000000000",
	84:  "100001111111110100000000000000",
	85:  "100000110100000000000000000000",
	86:  "100000111110100000000000000000",
	87:  "100000111111110100000000000000",
	88:  "100000010100000000000000000000",
	89:  "100000011111010000000000000000",
	90:  "100000011111110100000000000000",
	91:  "100000011111111101000000000000",
	92:  "100000001010000000000000000000",
	93:  "100000001110100000000000000000",
	94:  "100000001111101000000000000000",
	95:  "100000001111111010000000000000",
	96:  "100000001111111110100000000000",
	97:  "100000000101000000000000000000",
	98:  "100000000111010000000000000000",
	99:  "100000000111110100000000000000",
	100: "100000000111111101000000000000",
	101: "100000000111111111010000000000",
	102: "100000000011010000000000000000",
	103: "100000000011110100000000000000",
	104: "100000000011111101000000000000",
	105: "100000000011111111010000000000",
	106: "1000000000111111111101000000000",
	107: "100000000001101000000000000000",
	108: "100000000001111010000000000000",
	109: "100000000001111110100000000000",
	110: "100000000001111111101000000000",
	111: "10000000000111111111101000000000",
	112: "110110100000000000000000000000",
	113: "110111101000000000000000000000",
	114: "110111111010000000000000000000",
	115: "110111111111010000000000000000",
	116: "110011010000000000000000000000",
	117: "110011111010000000000000000000",
	118: "110011111111010000000000000000",
	119: "110001010000000000000000000000",
	120: "110001111101000000000000000000",
	121: "110001111111110100000000000000",
	122: "110000111010000000000000000000",
	123: "110000111111101000000000000000",
	124: "110000010100000000000000000000",
	125: "110000011111101000000000000000",
	126: "110000001010000000000000000000",
	127: "110000001111110100000000000000",
}

const symbolTime = 750 * time.Microsecond

func binaryToIQ(cmd string, sampleRate int) []byte {
	const f1 = 6290 // Hz, freq for zero
	const f2 = 1760 // Hz, freq for one

	samplesPerSymbol := int(math.Round(symbolTime.Seconds() * float64(sampleRate)))

	var out []byte
	var angle float64
	angle = -0.5 * math.Pi
	for _, b := range cmd {
		switch b {
		case '1':
			for j := 0; j < int(samplesPerSymbol); j++ {
				iq := 80 * cmplx.Exp(-1.0*1i*complex(angle, 0))
				out = append(out, byte(int8(math.Round(real(iq)))))
				out = append(out, byte(int8(math.Round(imag(iq)))))
				angle += 2.0 * math.Pi * f2 * (1.0 / float64(sampleRate))
			}
		case '0':
			for j := 0; j < int(samplesPerSymbol); j++ {
				iq := 80 * cmplx.Exp(-1.0*1i*complex(angle, 0))
				out = append(out, byte(int8(math.Round(real(iq)))))
				out = append(out, byte(int8(math.Round(imag(iq)))))
				angle += 2.0 * math.Pi * f1 * (1.0 / float64(sampleRate))
			}
		default:
			log.Fatalf("invalid char in cmd: %v", b)
		}
	}
	return out
}

func durationToRepeat(duration time.Duration) int {
	repeatDuration := time.Duration(len(NickCmd)+len(CollarID1)+len(intensities[0])) * symbolTime
	repeat := int(duration / repeatDuration)
	if repeat < 3 {
		return 3
	}
	return repeat
}

// GenerateIQ returns signed 8-bit IQ data for a Dogtra 2300NCP collar
// command. intensity must be between 0 and 127.
func GenerateIQ(sampleRate int, cmd Cmd, id CollarID, intensity int, duration time.Duration) []byte {
	intensityBin, ok := intensities[intensity]
	if !ok {
		log.Fatalf("invalid intensity %d, expected value between 0 and 127", intensity)
	}

	var builder strings.Builder
	builder.WriteString(prefix)
	for i := 0; i < durationToRepeat(duration); i++ {
		builder.WriteString(string(cmd))
		builder.WriteString(string(id))
		builder.WriteString(intensityBin)
	}
	return binaryToIQ(builder.String(), sampleRate)
}
